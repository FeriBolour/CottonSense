function exportGroundTruthToJSON(gTruth, filename, varargin)
%exportGroundTruthToJSON Export groundTruth object to a JSON format file
%
%   exportCOCO(GroundTruth, FILENAME) exports the groundTruth object to a
%   JSON format file specified by the FILENAME. If FILENAME already exists,
%   then exportGroundTruthToJSON overwrites the file.
%
%  Inputs:
%  -------
%
%  GTruth       - A groundTruth object.
%
%  FILENAME     - Name of file. A character vector or string.
%
% exportGroundTruthToJSON(GroundTruth,FILENAME, 'PARAM1', VAL1, 'PARAM2', VAL2, ...)
%  specifies additional name-value pairs described below:
%
%  'Info'       - A scalar structure with fields specifying the information
%                   about the dataset and the annotations.
%                     Default: struct( ...
%                                       'year', year(date), ...
%                                       'description', 'Created using MATLAB', ...
%                                       'date_created', date ...
%                                     )
%
%  'License'   - A structure array with fields specifying the information
%                   about the licenses applicable to the dataset and the
%                   annotations.
%                     Default: []
%
%  'COCO'      - A boolean value that specifies the output data format of
%                   the JSON file. If this is set to true, the output is a
%                   COCO data format JSON file else it would follow the
%                   custom data format.
%                    Default: false
%
% Limitations:
% ------------
%
% - Custom label types cannot be exported to the JSON file.
% - You cannot export data from a custom reader ground truth datasource to
%   a JSON file format.
% - Only Polygon and crowd Pixel Label ROIs can be exported to the COCO 
%   object detection data format.
% - The JSON file generated by the "exportGroundTruthToJSON" helper function
%   cannot be imported back into MATLAB as a ground truth object.
%

% Copyright 2020 The MathWorks, Inc.

% Validate number of input arguments
narginchk(2,inf)

% Parse inputs
p = parseInputs(gTruth, filename, varargin);

% Validate and open file
fid = openAnnotationFile(p.Results.filename);

% Get parsed Inputs
gTruth = p.Results.gTruth;
info = p.Results.Info;
licenses = p.Results.License;
cocoFlag = p.Results.COCO;

% Format the licenses structure array such that the output of jsonencode is
% always a list of licenses '[{}]'.
if numel(licenses) == 1
    licenses = {{licenses}};
end

% Process Label Definitions
[categoriesTable, currUnsupportedLabelDataVarIdx]  = processLabelDefinitions( ...
    gTruth, cocoFlag);

% Encode associated Images/Videos data
[data, dataVariableName] = encodeDataset(gTruth);

% Encode LabelData
annotations  = encodeLabelData(...
    gTruth, ...
    categoriesTable, ...
    data, ...
    currUnsupportedLabelDataVarIdx, ...
    cocoFlag ...
    );

% In case of COCO, remove Pixel Label ROIs from the categoriesTable
if cocoFlag
    categoriesTable(categoriesTable.type == labelType.PixelLabel, :) = [];
end

% Encode the data into structure and write it to the annotation file
fprintf(...
    fid,'%s', ...
    jsonencode( ...
    struct('info', info, ...
    'licenses', licenses, ...
    'categories', categoriesTable, ...
    dataVariableName, data, ...
    'annotations', {annotations}) ...
    )...
    );

% Close the file
fclose(fid);
end

function fid = openAnnotationFile(filename)
% Validate and open/create the file with specified filename and return the
% file id

[filepath,name,ext] = fileparts(filename);

% Check file name
if isempty(name)
    error(message('vision:labeler:AnnotationFileNameEmptyError'));
end

if isempty(ext)
    % Default the file extension to .json if it is not provided.
    filename = [name '.json'];
else
    % If the file extension is other than .json display an error.
    if ~strcmp(ext, '.json')
        error(message('vision:labeler:AnnotationFileExtensionError'));
    end
end

% Build file path
if isempty(filepath)
    % If filepath is not passed in, create the fullpath to current directory
    fname = fullfile(pwd, filename);
else
    % Path is not validated. Validation is left to the file reader.
    % It can be an absolute path or a relative path.
    fname = filename;
end

% Create or Open the file
fid = fopen(fname,'w+');

% Display an error if the file cannot be created or accessed
if fid == -1
    error(message('vision:labeler:AnnotationFileCreationError'));
end
end

function p = parseInputs(gTruth, filename, varargs)
% Parse inputs and return the inputParser object

p = inputParser;
p.addRequired(...
    'gTruth', @(gTruth) validateattributes(gTruth, ...
    {'groundTruth'}, {'scalar', 'nonempty'}));
p.addRequired(...
    'filename', @(filename) validateattributes(filename, ...
    {'char','string'}, {'scalartext', 'nonempty'}));
p.addParameter(...
    'Info', struct( ...
    'year', year(datetime), ...
    'description', 'Created using MATLAB', ...
    'date_created', datetime ...
    ), ...
    @(info) validateattributes(info, {'struct'}, {'scalar', 'nonempty'}));
p.addParameter(...
    'License', [], ...
    @(license) validateattributes(license, {'struct'}, {'vector', 'nonempty'}));
p.addParameter(...
    'COCO', false, ...
    @(coco) validateattributes(coco, {'logical'}, {'scalar', 'nonempty'}));
p.PartialMatching = false; % Match full property names only (case-insensitive)
p.StructExpand = false;
p.parse(gTruth, filename, varargs{:})
end

function [categoriesTable, currUnsupportedLabelDataVarIdx] = ...
    processLabelDefinitions(gTruth, cocoFlag)
% Process LabelDefinitions table of the ground truth object

if cocoFlag
    % Include only labels of type polygon and pixellabel
    polyLabelIdxs = (gTruth.LabelDefinitions.Type == labelType.Polygon);
    pixelLabelIdxs = (gTruth.LabelDefinitions.Type == labelType.PixelLabel);
    validCOCOLabelDefIdxs = polyLabelIdxs | pixelLabelIdxs;
    categoriesTable = gTruth.LabelDefinitions(validCOCOLabelDefIdxs, :);
    
    % Following label types are ignored while exporting to COCO Object
    % Detection annotations data format
    unsupportedLabelTypes = [...
        labelType.Rectangle, ...
        labelType.Line, ...
        labelType.ProjectedCuboid, ...
        labelType.Scene, ...
        labelType.Custom ...
        ];
else
    validLabelDefIdxs = (gTruth.LabelDefinitions.Type ~= labelType.Custom);
    categoriesTable = gTruth.LabelDefinitions(validLabelDefIdxs, :);
    
    % Custom label type is not supported
    unsupportedLabelTypes = [labelType.Custom];
end

% Create categoriesTable by adding variable 'Id' to the LabelDefinitions table
categoriesTable = addvars(...
    categoriesTable, ...
    reshape(1:1:size(categoriesTable,1),[],1), ...
    'Before', 1, ...
    'NewVariableNames', 'id');

% Process sublabels and attribtues if Hierarchy variable exists
if ismember('Hierarchy', categoriesTable.Properties.VariableNames)
    categoriesTable(:,{'attributes', 'sublabels'}) = rowfun(...
        @processAttributesSublabelsDefinitions, ...
        categoriesTable, ...
        'InputVariables', 'Hierarchy', ...
        'Numoutputs', 2, ...
        'OutputVariableNames', {'attributes', 'sublabels'});
    
        % Remove Hierarchy variable
        categoriesTable = removevars(categoriesTable, {'Hierarchy'});
else
    categoriesTable(:,{'attributes', 'sublabels'}) = table(...
        repmat({[]}, size(categoriesTable, 1), 1), ...
        repmat({[]}, size(categoriesTable, 1), 1) ...
        );
end

% Modify categoriesTable variable names to make them consistent with the
% basic format of the COCO Annotations

% Rename variable name "LabelColor" field to "color"
categoriesTable.Properties.VariableNames( ...
    ismember(categoriesTable.Properties.VariableNames, {'LabelColor'})) = {'color'};

% Rename variable name "Group" field to "supercategory"
categoriesTable.Properties.VariableNames( ...
    ismember(categoriesTable.Properties.VariableNames, {'Group'})) = {'supercategory'};

% Change all the variables to camelCase
categoriesTable.Properties.VariableNames = cellfun(...
    @(varName) [lower(varName(1)), varName(2:end)], ...
    categoriesTable.Properties.VariableNames, 'UniformOutput', false);

% Display warning message if the label type is not supported
currentUnsupportedLabelTypes = unsupportedLabelTypes( ...
    ismember(unsupportedLabelTypes, unique(gTruth.LabelDefinitions.Type)));

currUnsupportedLabelDataVarIdx = ismember(...
    gTruth.LabelData.Properties.VariableNames, ...
    gTruth.LabelDefinitions.Name(ismember(...
    gTruth.LabelDefinitions.Type, ...
    unsupportedLabelTypes))...
    );

if cocoFlag
    % Add pixel Label Data to unsupported label data variables Idx
    % Crowd pixel label data is processed separately in 'encodeLabelData'
    % function
    pixelLabelDataIdx = ismember(...
        gTruth.LabelData.Properties.VariableNames, ...
        {'PixelLabelData'} ...
        );
    currUnsupportedLabelDataVarIdx = currUnsupportedLabelDataVarIdx | pixelLabelDataIdx;
end

if ~isempty(currentUnsupportedLabelTypes)
    if cocoFlag
        warning(message('vision:labeler:UnsupportedLabelTypesCOCOWarning', ...
            char(join(arrayfun(@(x) char(x), currentUnsupportedLabelTypes, ...
            'UniformOutput', false), ', '))));
    else
        warning(message('vision:labeler:UnsupportedLabelTypesWarning', ...
            char(join(arrayfun(@(x) char(x), currentUnsupportedLabelTypes, ...
            'UniformOutput', false), ', '))));
    end
end
end

function [attributes, sublabels] = processAttributesSublabelsDefinitions(s)
% Process attributes and sublabels definitions of a label

s = s{1};
attributes = [];
sublabels = [];
if isstruct(s)
    % Remove duplicate fields - Type, Description from within Hierarchy as they
    % are already present in the categoriesTable
    if isfield(s, 'Type')
        s = rmfield(s, 'Type');
    end
    if isfield(s, 'Description')
        s = rmfield(s, 'Description');
    end
    
    fields = fieldnames(s);
    numFields = numel(fields);
    numSubLabels = sum(structfun(@(x) isfield(x, 'Type'), s));
    numAttributes  = numFields - numSubLabels;
    attributes = cell(1, numAttributes);
    sublabels = cell(1, numSubLabels);
    subLabelIdx = 1;
    attributeIdx = 1;
    
    for fieldIdx = 1:numFields
        fieldName = fields{fieldIdx};
        fieldValue = s.(fieldName);
        if isstruct(fieldValue)
            % If the value of a field is a structure it is either an
            % attribute or a sublabel
            fieldValue.('name') = fieldName;
            if isfield(fieldValue, 'Type')
                % If structure contains 'Type' then it is a sublabel
                subLabelFields = fieldnames(fieldValue);
                numSubLabelFields = numel(subLabelFields);
                numSubLabelAttributes = sum(structfun(@isstruct, fieldValue));
                subLabelAttributes = cell(1, numSubLabelAttributes);
                subLabelAttributeIdx = 1;
                for subLabelFieldIdx = 1:numSubLabelFields
                    subLabelFieldName = subLabelFields{subLabelFieldIdx};
                    subLabelFieldValue = fieldValue.(subLabelFieldName);
                    if isstruct(subLabelFieldValue)
                        subLabelFieldValue.('name') = subLabelFieldName;
                        subLabelAttributes{subLabelAttributeIdx} = changeFieldNamesToCamelCase(subLabelFieldValue);
                        subLabelAttributeIdx = subLabelAttributeIdx + 1;
                        fieldValue = rmfield(fieldValue, subLabelFieldName);
                    end
                end
                if isfield(fieldValue, 'LabelColor')
                    fieldValue.('color') = fieldValue.LabelColor;
                    fieldValue = rmfield(fieldValue, {'LabelColor'});
                end
                fieldValue.attributes = subLabelAttributes;
                sublabels{subLabelIdx} = changeFieldNamesToCamelCase(fieldValue);
                subLabelIdx = subLabelIdx + 1;
            else
                % Attribute
                attributes{attributeIdx} = changeFieldNamesToCamelCase(fieldValue);
                attributeIdx = attributeIdx + 1;
            end
        end
    end
end
attributes = {attributes};
sublabels = {sublabels};
end

function s = changeFieldNamesToCamelCase(s)
% Change the format of field names to camelCase

fields = fieldnames(s);
numFields = numel(fields);
for fieldIdx = 1:numFields
    fieldName = char(fields(fieldIdx));
    if ~strcmp(lower(fieldName(1)), fieldName(1))
        s.([lower(fieldName(1)), fieldName(2:end)]) = s.(fieldName);
        s = rmfield(s, fieldName);
    end
end
end

function [data, dataVariableName] = encodeDataset(gTruth)
% Encode Images/Videos into the JSON format similar to that of COCO

% Extract images/videos based on gTruth Data Source type
isVideo = false;
switch gTruth.DataSource.SourceType
    case vision.internal.labeler.DataSourceType.VideoReader
        % Extract Videos
        data = extractVideoData(gTruth);
        isVideo = true;
    case {vision.internal.labeler.DataSourceType.ImageDatastore ,...
            vision.internal.labeler.DataSourceType.ImageSequence}
        % Extract Images
        data = extractImageData(gTruth);
    case vision.internal.labeler.DataSourceType.CustomReader
        error(message('vision:labeler:CustomReaderDataSourceNotSupportedError'));
    otherwise
        error(message('vision:labeler:DataSourceTypeNotSupportedError'));
end

% Variable name for data objects in the JSON file
if isVideo
    dataVariableName = 'video';
else
    dataVariableName = 'images';
end
end

function images = extractImageData(gTruth)
% Extract images metadata

imageFileFullPaths = gTruth.DataSource.Source(:);
[~, imageFileNames, imageFileExts] = fileparts(imageFileFullPaths);
numImages = size(imageFileNames,1);
imageIds = reshape(1:1:numImages, [], 1);
imageWidth = zeros(numImages,1);
imageHeight = zeros(numImages,1);
imageLastModifiedDate = repmat(...
    datetime('now','Format', 'yyyy-MM-dd hh:mm:ss'), ...
    numImages,1);

% Extract metadata from image files
for i = 1:numImages
    imageInfo = imfinfo(imageFileFullPaths{i});
    imageWidth(i) = imageInfo.Width;
    imageHeight(i) = imageInfo.Height;
    imageLastModifiedDate(i) = datetime(imageInfo.FileModDate, ...
        'Format', 'yyyy-MM-dd hh:mm:ss');
end

% Format Image File names
if numImages == 1
    imageFileNames = {imageFileNames};
end
imageFileNamesWithExt = strcat(imageFileNames, imageFileExts);

% Store the extracted data in table
if istimetable(gTruth.LabelData)
    % If LabelData is a timetable add the time column.
    images = table( ...
        'Size', [numImages 7], ...
        'VariableNames',{ ...
        'id', ...
        'time_stamp', ...
        'width', ...
        'height', ...
        'file_name', ...
        'file_path', ...
        'date_captured' ...
        }, ...
        'VariableTypes', {...
        'uint64', ...
        'double', ...
        'uint64', ...
        'uint64', ...
        'string', ...
        'string', ...
        'datetime' ...
        } ...
        );
    
    images(:,:) = table(imageIds, seconds(gTruth.LabelData.Time), imageWidth, ...
        imageHeight, imageFileNamesWithExt, imageFileFullPaths, imageLastModifiedDate);
else
    images = table( ...
        'Size', [numImages 6], ...
        'VariableNames',{...
        'id', ...
        'width', ...
        'height', ...
        'file_name', ...
        'file_path', ...
        'date_captured' ...
        }, ...
        'VariableTypes', { ...
        'uint64', ...
        'uint64', ...
        'uint64', ...
        'string', ...
        'string', ...
        'datetime' ...
        } ...
        );
    
    images(:,:) = table(imageIds, imageWidth, imageHeight, imageFileNamesWithExt, ...
        imageFileFullPaths, imageLastModifiedDate);
end
end

function video = extractVideoData(gTruth)
% Get the video file info
videoInfo = mmfileinfo(gTruth.DataSource.Source);

% Format the data
numImages = numel(gTruth.DataSource.TimeStamps);

video = table( ...
    'Size', [numImages 7], ...
    'VariableNames',{ ...
    'id', ...
    'time_stamp', ...
    'width', ...
    'height', ...
    'file_name', ...
    'file_path', ...
    'date_captured' ...
    }, ...
    'VariableTypes', { ...
    'uint64', ...
    'double', ...
    'uint64', ...
    'uint64', ...
    'string', ...
    'string', ...
    'datetime' ...
    } ...
    );

video(:,:) = table(...
    reshape(1:1:numImages, [], 1), ...
    seconds(gTruth.DataSource.TimeStamps), ...
    repmat(videoInfo.Video.Width, numImages, 1), ...
    repmat(videoInfo.Video.Height, numImages, 1), ...
    repmat(videoInfo.Filename, numImages, 1), ...
    repmat(fullfile(videoInfo.Path, videoInfo.Filename), numImages, 1), ...
    repmat(datetime('now','Format', 'yyyy-MM-dd hh:mm:ss'), numImages, 1) ...
    );
end

function annotations = encodeLabelData(gTruth, categoriesTable, data, ...
    currUnsupportedLabelDataVarIdx, cocoFlag)
% Encode label data into JSON format similar to that of COCO Annotations

% Determine the number of valid annotations and their corresponding row, column indices.
validIdx = getValidAnnotationsIdx(gTruth, find(~currUnsupportedLabelDataVarIdx));
numAnnotations = full(sum(validIdx, 'all'));

% Get indices of validIdx of only the locations where the valid annotations exist
[imageIdxs, columnIdxs, ~] = find(validIdx);
imageIdxs = reshape(imageIdxs, 1, []);
columnIdxs = reshape(columnIdxs, 1, []);

% Track Annotation ID and Index separately as some annotations do not have Annotation ID
annotationId = 1;
annotationIdx = 1;
annotations = cell(numAnnotations,1);

% Find corresponding label definitions data for each valid columIdx to
% avoid repeated querying for the same Idx
columnIdxsMap = mapLabelColumnIdxData(gTruth, categoriesTable, unique(columnIdxs));

% Iterate through the valid indices of the LabelData table of the Ground Truth object
for idx = 1:length(imageIdxs)
    columnIdx = columnIdxs(idx);
    imageIdx = imageIdxs(idx); % ImageIdx is equal to the Id of the image
    
    % Get label type and Id
    currLabelType = columnIdxsMap(columnIdx).type;
    categoryId = columnIdxsMap(columnIdx).id;
    subLabelNameTypeMap = columnIdxsMap(columnIdx).subLabelNameTypeMap;
    
    % Store Ids Information in a structure
    idInfo = struct(...
        'annotationId', annotationId, ...
        'imageId', imageIdx, ...
        'categoryId', categoryId ...
        );
    
    % Store Current Image information in a structure
    imageInfo = getCurrentImageInfo(imageIdx, data);
    
    % Number of annotations for the current image and current label
    currNumAnnotations = full(validIdx(imageIdx, columnIdx));
    
    % Encode the data according to their label type.
    switch currLabelType
        case labelType.Polygon
            % Polygon ROI
            polygonLabelData = gTruth.LabelData{imageIdx, columnIdx}{1};
            if isnumeric(polygonLabelData)
                polygonLabelData = {polygonLabelData};
            end
            annotations(annotationIdx:annotationIdx+currNumAnnotations-1) = ...
                encodePolygonLabelData(polygonLabelData, imageInfo, ...
                subLabelNameTypeMap, cocoFlag, idInfo);
            annotationId = annotationId + currNumAnnotations;
        case labelType.PixelLabel
            % Pixel ROI
            pixelLabelData = char(gTruth.LabelData{imageIdx, 'PixelLabelData'});
            annotation = encodePixelLabelData(pixelLabelData, ...
                categoriesTable.pixelLabelID, idInfo);
            if ~isempty(annotation)
                % Annotation is empty in case the pixel label image has no
                % segments
                annotations(annotationIdx:annotationIdx+currNumAnnotations-1) = annotation;
            else
                annotationIdx = annotationIdx - currNumAnnotations;
            end
        case {labelType.Rectangle, labelType.ProjectedCuboid}
            % RPC (Rectangle & ProjectedCuboid) ROI store the data in a similar
            % format
            currLabelData = gTruth.LabelData{imageIdx, columnIdx}{1};
            annotations(annotationIdx:annotationIdx+currNumAnnotations-1) = ...
                encodeRPCLabelData(currLabelData, imageInfo, subLabelNameTypeMap,...
                cocoFlag, idInfo);
            annotationId = annotationId + currNumAnnotations;
        case labelType.Line
            % Line ROI
            lineLabelData = gTruth.LabelData{imageIdx, columnIdx}{1};
            if isnumeric(lineLabelData)
                lineLabelData = {lineLabelData};
            end
            annotations(annotationIdx:annotationIdx+currNumAnnotations-1) = ...
                encodeLineLabelData(...
                lineLabelData, imageInfo, subLabelNameTypeMap, ...
                cocoFlag, idInfo);
            annotationId = annotationId + currNumAnnotations;
        case labelType.Scene
            % Scene
            sceneLabelData = gTruth.LabelData{imageIdx, columnIdx};
            annotations(annotationIdx:annotationIdx+currNumAnnotations-1) = ...
                encodeSceneLabelData(sceneLabelData, idInfo);
            annotationId = annotationId + currNumAnnotations;
    end
    annotationIdx = annotationIdx + currNumAnnotations;
end

% Process Crowd annotations
if cocoFlag && ismember({'PixelLabelData'}, gTruth.LabelData.Properties.VariableNames)
    crowdPixelLabelIdxs = cellfun(@validCrowdLabelName, ...
        categoriesTable.name) & (categoriesTable.type == labelType.PixelLabel);
    
    crowdPixelLabelNames = categoriesTable.name(crowdPixelLabelIdxs);
    crowdPolygonLabelNames = cellfun(@extractNameFromCrowdLabelName, ...
        crowdPixelLabelNames, 'UniformOutput', false);
    validCrowdPolygonLabelNames = crowdPolygonLabelNames(ismember(...
        crowdPolygonLabelNames, ...
        categoriesTable.name(categoriesTable.type == labelType.Polygon)));
    
    for imageIdx = 1:size(gTruth.LabelData.PixelLabelData,1)
        imageInfo = getCurrentImageInfo(imageIdx, data);
        for validCrowdPolygonLabelIdx = 1:size(validCrowdPolygonLabelNames,1)
            currCategoryName = validCrowdPolygonLabelNames(validCrowdPolygonLabelIdx);
            currCategory = categoriesTable(ismember(categoriesTable.name, ...
                currCategoryName), :);
            idInfo.annotationId = annotationId;
            idInfo.imageId = imageIdx;
            idInfo.categoryId = currCategory.id(1);
            
            crowdAnnotation = encodeCrowdAnnotation(gTruth, categoriesTable, ...
                currCategoryName, imageInfo, idInfo);
            if ~isempty(crowdAnnotation)
                annotations(annotationIdx) = crowdAnnotation;
                annotationId = annotationId + 1;
                annotationIdx = annotationIdx + 1;
            end
        end
    end
end

% Remove empty annotations if any
if size(annotations,1) > 0
    annotations = annotations(~cellfun(@isempty, annotations));
end
end

function validIdx = getValidAnnotationsIdx(gTruth, supportedROIIdx)
% Function to create a sparse matrix for all the valid annotations in the
% label data

labelDataSize = size(gTruth.LabelData);
validIdx = zeros(labelDataSize);
for colIdx = supportedROIIdx
    for rowIdx = 1:labelDataSize(1)
        count = 0;
        x = gTruth.LabelData{rowIdx, colIdx};
        if iscell(x)
            x = x{1};
        end
        if ~isempty(x)
            % Check if label data is not empty
            if isstruct(x)
                % Data is stored in structure arrays when annotations have
                % sublabels, attributes
                count = size(x,2);
            elseif isnumeric(x)
                if size(x,2) >= 4
                    % Rectangle, ProjectedCuboid ROI Data is stored as a matrix
                    % in case labels do not have any sublabels, attributes
                    count = size(x,1);
                elseif size(x,2) == 2
                    % Line, Polygon ROI Data is stored as a matrix in case
                    % labels do not have any sublabels, attributes and when
                    % the number of ROIs is equal to 1.
                    count = 1;
                end
            elseif ischar(x)
                % In case of pixel label data
                count = 1;
            elseif islogical(x)
                % In case of scene label data
                if x
                    % Scene annotation is created only valid if is true
                    count = 1;
                end
            elseif iscell(x)
                % Line, Polygon ROI Data is stored as a vector of cell
                % arrays in case labels do not have any sublabels,
                % attributes and when the number of ROIs is >= 2.
                count = size(x,1);
            end
        end
        validIdx(rowIdx, colIdx) = count;
    end
end
validIdx = sparse(validIdx);
end

function columnIdxsMap = mapLabelColumnIdxData(gTruth, categoriesTable, columnIdxs)
% Map valid label data column variables to their corresponding label
% definitions data (Id, Type)

columnIdxsMap = containers.Map('KeyType','uint64','ValueType','any');
subLabelNameTypeMap = containers.Map;

for idx = 1:length(columnIdxs)
    columnIdx = columnIdxs(idx);
    % Check the Label Type of the current column.
    if strcmp(gTruth.LabelData.Properties.VariableNames{columnIdx},'PixelLabelData')
        % If column name is 'PixelLabelData' set the label type to
        % PixelLabel.
        if ~any(categoriesTable.type == labelType.PixelLabel)
            error(message('vision:labeler:PixelLabelDefinitionsNotFoundError'));
        end
        columnIdxsMap(columnIdx) = struct(...
            'type', labelType.PixelLabel, ...
            'id', [], ...
            'subLabelNameTypeMap', subLabelNameTypeMap ...
            );
    else
        % Determine the Label Type by finding its corresponding row in
        % Label Definitions table.
        categoryIdx = strcmp(gTruth.LabelData.Properties.VariableNames{...
            columnIdx},categoriesTable.name);
        if ~categoryIdx
            error(message('vision:labeler:LabelDefinitionsNotFoundError', ...
                gTruth.LabelData.Properties.VariableNames{columnIdx}));
        end
        currCategory = categoriesTable(categoryIdx,{'id', 'type', 'sublabels'});
        subLabelData = currCategory.sublabels{1};
        for subLabelIdx = 1:numel(subLabelData)
            currSubLabelData = subLabelData{subLabelIdx};
            subLabelNameTypeMap(currSubLabelData.name) = currSubLabelData.type;
        end
        columnIdxsMap(columnIdx) = struct(...
            'type', currCategory{1,'type'}, ...
            'id', currCategory{1,'id'}, ...
            'subLabelNameTypeMap', subLabelNameTypeMap ...
            );
    end
end
end

function imageInfo = getCurrentImageInfo(imageIdx, data)
% Get Image Information based on its index in Label Data Table

imageInfo = data(data.id == imageIdx,:);
imageInfo = struct('width', imageInfo.width(1), 'height', imageInfo.height(1), ...
    'idx', imageIdx);
end

function annotations = encodePolygonLabelData(polygonLabelData, imageInfo, ...
    subLabelNameTypeMap, cocoFlag, idInfo)
% Encode Polygon label data

if cocoFlag
    % If exporting to COCO format, 'position' field is replaced by
    % 'segmentation'.
    dataFieldName = 'segmentation';
else
    dataFieldName = 'position';
end

if isstruct(polygonLabelData)
    % Structure - implies that data contains sublabels and/or attributes.
    % ROIs are stacked columnwise
    numPolygons = size(polygonLabelData,2);
    annotations = cell(numPolygons,1);
    for polygonIdx = 1:1:numPolygons
        [attributes, sublabels] = encodeLabelDataAttributesSublabels(rmfield(polygonLabelData(polygonIdx), 'Position'), imageInfo, subLabelNameTypeMap, cocoFlag);
        annotation = struct;
        % Number of input arguments = 4 in case of sublabels and
        % sublabels do not contain Id Information
        if nargin == 5
            annotation.id = (idInfo.annotationId + polygonIdx - 1);
            annotation.image_id = idInfo.imageId;
            annotation.category_id = idInfo.categoryId;
        end
        annotation.(dataFieldName) = formatPolygonLabelData(polygonLabelData(polygonIdx).Position);
        if cocoFlag
            annotation.area = calculatePolygonArea(annotation.(dataFieldName){1});
            annotation.iscrowd = false;
            annotation.bbox = calculatePolygonBoundingBox(annotation.(dataFieldName){1});
        end
        annotation.attributes = attributes;
        annotation.sublabels = sublabels;
        annotations{polygonIdx} = annotation;
    end
else
    % ROIs are stacked rowwise - vector of cell arrays
    numPolygons = size(polygonLabelData,1);
    annotations = cell(numPolygons,1);
    for polygonIdx = 1:1:numPolygons
        annotation = struct;
        annotation.id = (idInfo.annotationId + polygonIdx - 1);
        annotation.image_id = idInfo.imageId;
        annotation.category_id = idInfo.categoryId;
        annotation.(dataFieldName) = formatPolygonLabelData(polygonLabelData{polygonIdx});
        if cocoFlag
            annotation.area = calculatePolygonArea(annotation.(dataFieldName){1});
            annotation.iscrowd = false;
            annotation.bbox = calculatePolygonBoundingBox(annotation.(dataFieldName){1});
        end
        annotation.attributes = [];
        annotation.sublabels = [];
        annotations{polygonIdx} = annotation;
    end
end
end

function polygonLabelData = formatPolygonLabelData(polygonLabelData)
% Format polygon data from Nx2 to 1x2*N

% Make co-ordinates 0-indexed
polygonLabelData = polygonLabelData - 0.5;
polygonLabelData(polygonLabelData < 0) = 0;
polygonLabelData = {reshape((polygonLabelData.'), 1, [])};
end

function area = calculatePolygonArea(polyPosition)
% Calculate area of the polygon

polyX = polyPosition(1:2:end);
polyY = polyPosition(2:2:end);
area = polyarea(polyX, polyY);
end

function bbox = calculatePolygonBoundingBox(polyPosition)
% Calculate minimum bounding box enclosing the polygon

polyX = polyPosition(1:2:end);
polyY = polyPosition(2:2:end);
minPolyX = min(polyX);
minPolyY = min(polyY);
bbox = [minPolyX minPolyY (max(polyX) - minPolyX) (max(polyY) - minPolyY)];
end

function annotations = encodePixelLabelData(pixelLabelData, pixelLabelIDs, idInfo)
% Encode Pixel label data

annotations = {};
% Read PixelLabelImage
pixelLabelImage = imread(pixelLabelData);

isRGB = false;
% Check if pixel label image has 1 or 3 channels
if size(pixelLabelImage,3) == 1
    segmentIds = cell2mat(cellfun(@(x) extractPixelID(x, isRGB) , ...
        pixelLabelIDs, 'UniformOutput', false));
    segmentIdx = ismember(segmentIds, ...
        reshape(unique(pixelLabelImage),[],1), 'rows');
    segmentIds = segmentIds(segmentIdx);
    categoryIds = find(segmentIdx);
elseif size(pixelLabelImage, 3) == 3
    isRGB = true;
    segmentIds = cell2mat(cellfun(@(x) extractPixelID(x, isRGB) , ...
        pixelLabelIDs, 'UniformOutput', false));
    segmentIdx = ismember(segmentIds, ...
        reshape(permute(pixelLabelImage, [3, 2, 1]), 3, [])', 'rows');
    segmentIds = segmentIds(segmentIdx, :);
    categoryIds = find(segmentIdx);
else
    error(message('vision:labeler:PixelLabelImageChannelsError'));
end
segments = cell(size(segmentIds,1),1);
for segmentIdx = 1:size(segmentIds,1)
    if isRGB
        segmentID = segmentIds(segmentIdx, :);
        currSegment = pixelLabelImage == reshape(segmentID, 1, 1, 3);
        segmentID = segmentID(1) + (segmentID(2) .* 256) + (segmentID(3) * 256.^2);
        currSegment = currSegment(:,:,1);
    else
        segmentID = segmentIds(segmentIdx);
        currSegment = pixelLabelImage == segmentID;
    end
    categoryId = categoryIds(segmentIdx);
    segments(segmentIdx) = { ...
        struct( ...
        'id', segmentID, ...
        'category_id', categoryId, ...
        'area', sum(currSegment, 'all') ...
        )};
end
if size(segmentIds,1) >= 1
    [~, name, ext] = fileparts(pixelLabelData);
    annotations{1} = struct( ...
        'image_id', idInfo.imageId, ...
        'file_name', [name ext], ...
        'file_path', pixelLabelData, ...
        'segments_info', {segments}...
        );
end
end

function pixelID = extractPixelID(x, isRGB)
% Function to return consistent pixelIDs

if isempty(x)
    % If correponding label is not of pixel label type
    if isRGB
        pixelID = [NaN NaN NaN];
    else
        pixelID = NaN;
    end
else
    if (isRGB && numel(x) == 3) || (~isRGB && numel(x) == 1)
        pixelID = x;
    else
        error(message('vision:labeler:PixelLabelIDPixelLabelImageChannelsMatchError'));
    end
end
end

function annotations = encodeRPCLabelData(rectLabelData, imageInfo, ...
    subLabelNameTypeMap, cocoFlag, idInfo)
% Encode Rectangle and Projected Cuboid label data

if isstruct(rectLabelData)
    % Structure - implies that data contains sublabels and/or attributes.
    % ROIs are stacked columnwise
    numRects = size(rectLabelData,2);
    annotations = cell(numRects,1);
    for rectIdx = 1:1:numRects
        [attributes, sublabels] = encodeLabelDataAttributesSublabels(...
            rmfield(rectLabelData(rectIdx), 'Position'), ...
            imageInfo, ...
            subLabelNameTypeMap, ...
            cocoFlag);
        annotation = struct;
        % Number of input arguments = 4 in case of sublabels and
        % sublabels do not contain Id Information
        if nargin == 5
            annotation.id = (idInfo.annotationId + rectIdx - 1);
            annotation.image_id = idInfo.imageId;
            annotation.category_id = idInfo.categoryId;
        end
        annotation.position = formatRPCLabelData(rectLabelData(rectIdx).Position);
        annotation.attributes = attributes;
        annotation.sublabels = sublabels;
        annotations{rectIdx} = annotation;
    end
else
    % ROIs are stacked rowwise - Mx4 numeric Matrix
    numRects = size(rectLabelData,1);
    annotations = cell(numRects,1);
    for rectIdx = 1:1:numRects
        annotation = struct;
        annotation.id = (idInfo.annotationId + rectIdx - 1);
        annotation.image_id = idInfo.imageId;
        annotation.category_id = idInfo.categoryId;
        annotation.position = formatRPCLabelData(rectLabelData(rectIdx,:));
        annotation.attributes = [];
        annotation.sublabels = [];
        annotations{rectIdx} = annotation;
    end
end
end

function rectLabelData = formatRPCLabelData(rectLabelData)
% To format Rectangle ROI Position data

% Convert position to 0-indexed format
if size(rectLabelData, 2) == 4
    rectLabelData = rectLabelData - 1;
    rectLabelData(rectLabelData < 0) = 0;
elseif size(rectLabelData, 2) == 8
    rectLabelDataUpdated = rectLabelData(:,1:3) - 1;
    rectLabelDataUpdated(rectLabelDataUpdated < 0) = 0;
    rectLabelData(:,1:3) = rectLabelDataUpdated;
end
end

function annotations = encodeLineLabelData(lineLabelData, imageInfo, ...
    subLabelNameTypeMap, cocoFlag, idInfo)
% Encode Line label data

if isstruct(lineLabelData)
    % Structure - implies that data contains sublabels and/or attributes.
    % ROIs are stacked columnwise
    numLines = size(lineLabelData,2);
    annotations = cell(numLines,1);
    for lineIdx = 1:1:numLines
        [attributes, sublabels] = encodeLabelDataAttributesSublabels( ...
            rmfield(lineLabelData(lineIdx), 'Position'), imageInfo, ...
            subLabelNameTypeMap, cocoFlag);
        annotation = struct;
        % Number of input arguments = 4 in case of sublabels and
        % sublabels do not contain Id Information
        if nargin == 5
            annotation.id = (idInfo.annotationId + lineIdx - 1);
            annotation.image_id = idInfo.imageId;
            annotation.category_id = idInfo.categoryId;
        end
        annotation.position = formatLineLabelData(lineLabelData(lineIdx).Position);
        annotation.attributes = attributes;
        annotation.sublabels = sublabels;
        annotations{lineIdx} = annotation;
    end
else
    % ROIs are stacked rowwise - vector of cell arrays
    numLines = size(lineLabelData,1);
    annotations = cell(numLines,1);
    for lineIdx = 1:1:numLines
        annotation = struct;
        annotation.id = (idInfo.annotationId + lineIdx - 1);
        annotation.image_id = idInfo.imageId;
        annotation.category_id = idInfo.categoryId;
        annotation.position = formatLineLabelData(lineLabelData{lineIdx});
        annotation.attributes = [];
        annotation.sublabels = [];
        annotations{lineIdx} = annotation;
    end
end
end

function lineLabelData = formatLineLabelData(lineLabelData)
% Format Line data from Nx2 to 1x2*N

% Convert position to 0-indexed format
lineLabelData = lineLabelData - 0.5;
lineLabelData(lineLabelData < 0) = 0;
lineLabelData = reshape((lineLabelData.'), 1, []);
end

function annotations = encodeSceneLabelData(sceneLabelData, idInfo)
% Encode Scene label data

annotations = [];
if sceneLabelData
    annotations = {struct( ...
        'id', idInfo.annotationId, ...
        'image_id', idInfo.imageId, ...
        'category_id', idInfo.categoryId ...
        )};
end
end

function [attributes, sublabels] = encodeLabelDataAttributesSublabels(labelData, ...
    imageInfo, subLabelNameTypeMap, cocoFlag)
% Extact and encode attributes and sublabels

fields = fieldnames(labelData);
numFields = numel(fields);
if numFields ~= 0
    numSubLabels = sum(isKey(subLabelNameTypeMap, fields));
    numAttributes  = numFields - numSubLabels;
else
    numSubLabels = 0;
    numAttributes = 0;
end

attributes = cell(1, numAttributes);
sublabels = cell(1, numSubLabels);
subLabelIdx = 1;
attributeIdx = 1;
for fieldIdx = 1:numFields
    fieldName = fields{fieldIdx};
    fieldValue = labelData.(fieldName);
    if isstruct(fieldValue)
        % If the value of a field is a structure, it is a sublabel
        switch subLabelNameTypeMap(fieldName)
            case labelType.Polygon
                fieldValue = encodePolygonLabelData(fieldValue, imageInfo, ...
                    containers.Map, cocoFlag);
            case {labelType.Rectangle, labelType.ProjectedCuboid}
                fieldValue = encodeRPCLabelData(fieldValue, imageInfo, ...
                    containers.Map, cocoFlag);
            case labelType.Line
                fieldValue = encodeLineLabelData(fieldValue, imageInfo, ...
                    containers.Map, cocoFlag);
            otherwise
                error(message('vision:labeler:SubLabelTypeNotSupportedError'));
        end
        % Format the sub label annotations to include sublabel name and
        % remove the sublabels field from sublabel annotations as sublabels
        % cannot have further sublabels
        fieldValue = formatSubLabelAnnotations(fieldValue, fieldName);
        sublabels{subLabelIdx} = fieldValue;
        subLabelIdx = subLabelIdx + 1;
    elseif ~isKey(subLabelNameTypeMap, fieldName)
        attributes{attributeIdx} = struct(...
            'name', fieldName, ...
            'value', fieldValue ...
            );
        attributeIdx = attributeIdx + 1;
    end
end
% Format attributes and sublabels as list of objects
if isempty(attributes)
    attributes = {};
end
if isempty(sublabels)
    sublabels = [];
else
    sublabels = reshape(vertcat(sublabels{:}), 1, []);
end
end

function annotations = formatSubLabelAnnotations(annotations, fieldName)
% Add 'name' field and remove sublabels fields from sublabel annotations
for idx = 1:numel(annotations)
    annotations{idx}.name = fieldName;
    annotations{idx} = rmfield(annotations{idx}, 'sublabels');
end
end

function res = validCrowdLabelName(labelName)
% Check if labelName is a Crowd Label Name

res = false;
labelName = char(labelName);
if length(labelName) >= 7 && ismember({'_crowd'}, labelName(end-5:end))
    res = true;
end
end

function labelName = extractNameFromCrowdLabelName(crowdLabelName)
% Extract corresponding polgon label name from crowd label name

crowdLabelName = char(crowdLabelName);
labelName = crowdLabelName(1:end-6);
end

function crowdAnnotation = encodeCrowdAnnotation(gTruth, categoriesTable, ...
    currCategoryName, imageInfo, idInfo)
% Encode crowd annotation based on crowd label category

crowdAnnotation = {};
crowdCategoryName = [char(currCategoryName) '_crowd'];
crowdCategoryDefIdx = strcmp(crowdCategoryName, categoriesTable.name);
if any(crowdCategoryDefIdx)
    crowdCategoryDef = categoriesTable(crowdCategoryDefIdx,:);
    pixelLabelImage = imread(char(gTruth.LabelData{imageInfo.idx, 'PixelLabelData'}));
    
    % Check if pixel label image has 1 or 3 channels
    if size(pixelLabelImage,3) == 1
        segment = pixelLabelImage == cell2mat(crowdCategoryDef.pixelLabelID);
    elseif size(pixelLabelImage, 3) == 3
        segment = pixelLabelImage == reshape(crowdCategoryDef.pixelLabelID, 1, 1, 3);
        segment = segment(:,:,1);
    else
        error(message('vision:labeler:PixelLabelImageChannelsError'));
    end
    
    if any(segment, 'all')
        segmentCounts = segmentToRLE(segment);
        segmentSize = [imageInfo.height, imageInfo.width];
        crowdAnnotation = struct;
        crowdAnnotation.id = idInfo.annotationId;
        crowdAnnotation.image_id = idInfo.imageId;
        crowdAnnotation.category_id = idInfo.categoryId;
        crowdAnnotation.segmentation = struct(...
            'counts', segmentCounts, ...
            'size', segmentSize ...
            );
        crowdAnnotation.area = sum(segment, 'all');
        crowdAnnotation.iscrowd = true;
        
        crowdAnnotation.bbox = calculateSegmentBoundingBox(segment);
        crowdAnnotation.attributes = {};
        crowdAnnotation.sublabels = {};
        crowdAnnotation = {crowdAnnotation};
    end
end
end

function rle = segmentToRLE(segment)
% Convert Mask to RLE

segment = reshape(segment, 1, []);
di = diff(segment);
transitions = find(di == 1 | di == -1); % transition Indices
rle = [transitions(1) diff(transitions)];

% Insert 0 at the beginning if the segment starts with a 1
if segment(1) == 1
    rle = [0 rle];
end

% To account for the counts after the last transition
segmentSize = size(segment,2);
if transitions(end) ~= (segmentSize - 1)
    lastCount = segmentSize - transitions(end);
else
    lastCount = 1;
end
rle = [rle lastCount];
end

function bbox = calculateSegmentBoundingBox(segment)
% Calculate the bounding box enclosing the segment

[row, col] = ind2sub(size(segment),find(segment));
% Convert to 0-indexed format
minRow = min(row) - 1;
maxRow = max(row) - 1;
minCol = min(col) - 1;
maxCol = max(col) - 1;
bbox = [minCol minRow (maxCol-minCol) (maxRow-minRow)];
bbox(bbox < 0) = 0;
end
